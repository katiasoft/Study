## 넘파이(Numpy)를 사용하는 이유

### 1. 파이썬의 넘파이(Numpy)는
* 배열을 쉽게 처리할 수 있도록 지원하는 파이썬의 패키지이다.
* 수치 계산을 위해 효율적으로 구현된 기능을 제공한다.
* 대규모 다차원 배열 데이터를 빠르고 효율적으로 사용한다.

### 2. 넘파이(Numpy)의 장점
* 빠르다. : 원소가 많아질수록 파이썬의 리스트보다 배열의 연산이 빠르다. 
* 편리하다. : 배열을 다루는데 필요한 메소드들이 구현되어있다.
* 상용된다. : 여러가지 환경에서 사용이 용이하다.

```python
# 넘파이 라이브러리 호출하기
import numpy as np
```
## 넘파이(Numpy)의 핵심, 배열(array)

### 1. 넘파이(Numpy)의 핵심인 배열(array)은
* 넘파이(Numpy)패키지의 ndarray클래스이다.
* 여러개의 데이터를 담고 있는 컨테이너형 자료구조이다.
* 동일한 데이터타입의 원소를 갖는 다차원배열이다.

### 2. 배열와 리스트의 비교 
* 위치에 대한 정보(index)로 요소를 가져오는 인덱싱(indexing) 비교 ex) 0번행과 2번행 불러오기
* 여러개의 요소를 집계하여 하나의 값으로 결과를 내는 집계연산 비교 ex) 각 행별 총합 구하기
* 각 요소별로 연산을 적용하는 요소간(element-wise) 연산 비교 ex) 각 요소별 1000과의 차이 구하기

위의 3가지를 리스트와 배열로써 비교하면 리스트에서는 불가능하거나 for문으로 작성해야하는 번거로움이 발생하나 배열에서는 손쉽게 작성할 수 있다.

```python
py_list = [
           [1,2,3],
           [10,20,30],
           [100,200,300]
]
py_list

>> [[1, 2, 3], [10, 20, 30], [100, 200, 300]]
```
```python
np_array = np.array(py_list)
np_array

>> array([[  1,   2,   3],
       [ 10,  20,  30],
       [100, 200, 300]])
```
```python
# 0번행과 2번행 불러오기 - 리스트
# py_list[[0,2]] 불가능
[py_list[0],py_list[2]]

>> [[1, 2, 3], [100, 200, 300]]
```
```python
# 0번행과 2번행 불러오기 - 배열
np_array[[0,2]]

>> array([[  1,   2,   3],
       [100, 200, 300]])
```
```python
# 각 행별 총합 구하기 - 리스트
[sum(row_list) for row_list in py_list]

>> [6, 60, 600]
```
```python
# 각 행별 총합 구하기 - 배열
np_array.sum(axis=1)

>> array([  6,  60, 600])
```
```python
# 각 요소별 1000과의 차이 구하기 - 리스트
[[1000 - v for v in row_list] for row_list in py_list]

>> [[999, 998, 997], [990, 980, 970], [900, 800, 700]]
```
```python
# 각 요소별 1000과의 차이 구하기 - 배열
1000 - np_array

>> array([[999, 998, 997],
       [990, 980, 970],
       [900, 800, 700]])
```

## Numpy 배열의 구성요소 
### 1. Numpy배열(Array)는
* 원소(elements), 자료형(Data-type), 모양(shape)으로 구성되어있다.
* 고유한 구성요소 조합은 배열(array)를 결정한다.
* 정의된 배열에서 원소(elements)의 개수는 바꿀수 없다.

```python
# 원소, 자료형, 모양 확인
py_list = [[1,2,3],[10,20,30],[100,200,300]]
ary = np.array(py_list)
```
```python
print(f'원소의 개수(size) : {ary.size}')
print(f'자료형(dtype) : {ary.dtype}')
print(f'모양(shape) : {ary.shape}')

>> 원소의 개수(size) : 9
자료형(dtype) : int64
모양(shape) : (3, 3)
```

### 2. 원소의 개수는 바꿀 수 없다.
* ndarray 클래스의 메소드에는 원소의 개수가 바뀌는 메소드가 없다.

```python
# 리스트에서 원소의 개수를 추가하면
py_list.append([1000,2000,3000])
py_list

>> [[1, 2, 3], [10, 20, 30], [100, 200, 300], [1000, 2000, 3000]]
```

```python
# 배열에서도 append 메소드를 사용한다면
ary.append([1000,2000,3000]) # 오류가 발생한다.

>> ---------------------------------------------------------------------------
AttributeError                            Traceback (most recent call last)
<ipython-input-16-e2142273fd30> in <module>()
      1 # 배열에서도 append 메소드를 사용한다면
----> 2 ary.append([1000,2000,3000])

AttributeError: 'numpy.ndarray' object has no attribute 'append'
```

```python
# 배열에서 원소의 개수를 추가하려면
ary = np.append(ary, [[1000,2000,3000]], axis=0)
ary
# np에서 새로 정의후 저장해야한다.

>> array([[   1,    2,    3],
       [  10,   20,   30],
       [ 100,  200,  300],
       [1000, 2000, 3000]])
```

## 배열의 자료형(Data Type)
### 1. 배열의 자료형(dtype ; data type)은
* 배열에 포함된 원소들의 자료형이다. 
* 하나의 배열은 하나의 자료형을 갖는다.
* 그러므로 배열의 모든원소값은 동일한 자료형을 갖는다.
* 매개변수와 속성명으로 dtype을 쓴다.

```python
# 배열 자료형(dtype) 확인하기
ary.dtype

>> dtype('int64')
```
### 2. 자동으로 설정되는 배열의 자료형
* 배열 생성시, 입력한 원소들의 자료형을 파악하여 자동으로 설정

```python
# 서로 다른 자료형을 원소로 갖는 리스트
py_list = [1, 1.2, False]
py_list

>> [1, 1.2, False]
```

```python
# 서로 다른 자료형을 원소는 배열을 정의하면
ary = np.array(py_list)
ary

>> array([1. , 1.2, 0. ])
```

```python
ary.dtype

>> dtype('float64')
```

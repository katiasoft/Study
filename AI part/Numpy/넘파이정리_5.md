## 단일 배열의 원소별 연산
### 절대값 구하기 np.abs( )

```python
import numpy as np
```
```python
np.abs(-1)

>> 1
```
```python
arr = np.array([[-1.7,-1.5, 0],[0.5,1. ,1.7]])
np.abs(arr)

>> array([[1.7, 1.5, 0. ],
       [0.5, 1. , 1.7]])
```

### 반올림을 적용하는 메소드 np.round( )

```python
np.round(1.5)

>> 2.0
```
```python
np.round(arr)   # 0.5의 반올림은 0이고 2.5의 반올림도 2.0을 가르킨다.

>> array([[-2., -2.,  0.],
       [ 0.,  1.,  2.]])
```

### 삼각함수를 적용하는 메소드 np.sin( ), np.cos( )

```python
np.sin(np.pi*0.5)

>> 1.0
```
```python
arr = np.array([0, np.pi*(1/2), np.pi, np.pi*(3/2)])
np.sin(arr)

>> array([ 0.0000000e+00,  1.0000000e+00,  1.2246468e-16, -1.0000000e+00])
```
```python
x = np.linspace(0, 10, 100)
sin = np.sin(x)
cos = np.cos(x)
```
```python
import matplotlib.pyplot as plt
```
```python
plt.plot(x, sin)
plt.plot(x, cos)
plt.show()
```

<img src="https://user-images.githubusercontent.com/69491771/95831420-f6ec1800-0d73-11eb-9fdb-6414526ccd4f.png" width="381" height="248">

### 지수함수를 적용하는 메소드 np.exp( )

```python
np.exp(1)

>> 2.718281828459045
```
```python
arr = np.array([-1,0,1,2])
np.exp(arr)

>> array([0.36787944, 1.        , 2.71828183, 7.3890561 ])
```
```python
x = np.linspace(0,3,30)
y = np.exp(x)
```
```python
plt.plot(x,y)
plt.show()
```

<img src="https://user-images.githubusercontent.com/69491771/95838231-7e3d8980-0d7c-11eb-9013-0bf2782b91b6.png" width="381" height="248">

### 로그함수를 적용하는 메소드 np.log( ), np.log2( ), np.log10( )

```python
 np.log(1)
 
 >> 0.0
```
```python
arr = [0.1, 1, 2, 10, np.exp(1), np.exp(10)]
np.log(arr)

>> array([-2.30258509,  0.        ,  0.69314718,  2.30258509,  1.        ,
       10.        ])
```
```python
x = np.linspace(1,20,60)
y = np.log(x)
```
```python
plt.plot(x,y)
plt.show()
```
<img src="https://user-images.githubusercontent.com/69491771/95838433-ba70ea00-0d7c-11eb-9127-99e5479ea970.png" width="381" height="248">

```python
print(f'arr : {arr}')

# 밑이 2인 로그를 적용하고 싶다면
# np.log(arr)/np.log(2)
np.log2(arr)

>> arr : [0.1, 1, 2, 10, 2.718281828459045, 22026.465794806718]
array([-3.32192809,  0.        ,  1.        ,  3.32192809,  1.44269504,
       14.42695041])
```
```python
print(f'arr : {arr}')

# 밑이 10인 로그를 적용하고 싶다면
# np.log(arr)/np.log(10)
np.log10(arr)

>> arr : [0.1, 1, 2, 10, 2.718281828459045, 22026.465794806718]
array([-1.        ,  0.        ,  0.30103   ,  1.        ,  0.43429448,
        4.34294482])
```

## 같은 크기를 갖는 벼열간 원소별 연산
- 같은 모양(shape)의 배열 간 사칙연산을 할 때는 같은 위치에 있는 원소값을 묶어 연산을 수행하고 결과를 반환한다.
- +, -, *, /


```python
arr_1 = np.array([[1,2,3],[4,5,6]])
arr_2 = np.array([[10,20,30],[40,50,60]])
```

### 같은 크기를 갖는 배열간 원소별 더하기(+)

```python
print(f'arr_1 : \n {arr_1}')
print(f'arr_2 : \n {arr_2}')

arr_1 + arr_2

>> arr_1 : 
 [[1 2 3]
 [4 5 6]]
arr_2 : 
 [[10 20 30]
 [40 50 60]]
array([[11, 22, 33],
       [44, 55, 66]])
```

### 같은 크기를 갖는 배열간 원소별 빼기(-)

```python
print(f'arr_1 : \n {arr_1}')
print(f'arr_2 : \n {arr_2}')

arr_1 - arr_2

>> arr_1 : 
 [[1 2 3]
 [4 5 6]]
arr_2 : 
 [[10 20 30]
 [40 50 60]]
array([[ -9, -18, -27],
       [-36, -45, -54]])
```

### 같은 크기를 갖는 배열간 원소별 곱하기(x)

```python
print(f'arr_1 : \n {arr_1}')
print(f'arr_2 : \n {arr_2}')

arr_1 * arr_2

>> arr_1 : 
 [[1 2 3]
 [4 5 6]]
arr_2 : 
 [[10 20 30]
 [40 50 60]]
array([[ 10,  40,  90],
       [160, 250, 360]])
```

### 같은 크기를 갖는 배열간 원소별 나누기(/)

```python
print(f'arr_1 : \n {arr_1}')
print(f'arr_2 : \n {arr_2}')

arr_1 / arr_2

>> arr_1 : 
 [[1 2 3]
 [4 5 6]]
arr_2 : 
 [[10 20 30]
 [40 50 60]]
array([[0.1, 0.1, 0.1],
       [0.1, 0.1, 0.1]])
```

## 배열과 스칼라간 원소별 연산
- 배열의 모든 원소에 스칼라 값을 확장하여 연산 적용
- 브로드캐스팅(Broadcasting)법칙

### 배열과 스칼라간 더하기(+)

```python
arr = np.array([[1,2,3],[4,5,6]])

# 모든 원소에 10씩 더하기
arr = arr + 10
arr 

>> array([[11, 12, 13],
       [14, 15, 16]])
```

### 배열과 스칼라간 빼기(-)

```python
# 각 원소를 5로 빼기
print(f'arr : \n{arr}')

arr - 5

>> arr : 
[[11 12 13]
 [14 15 16]]
array([[ 6,  7,  8],
       [ 9, 10, 11]])
```

### 배열과 스칼라간 나누기(/)

```python
# 각 원소를 10으로 나누기
print(f'arr : \n{arr}')

arr / 10

>> arr : 
[[11 12 13]
 [14 15 16]]
array([[1.1, 1.2, 1.3],
       [1.4, 1.5, 1.6]])
```

### 배열과 스칼라간 곱하기(x)

```python
# 각 원소를 10으로 곱하기
print(f'arr : \n{arr}')

arr * 10

>> arr : 
[[11 12 13]
 [14 15 16]]
array([[110, 120, 130],
       [140, 150, 160]])
```

## 다른 형태의 배열 간 원소별 연산
- 서로 다른 모양(shape)의 배열 간 연산을 할 경우 브로드캐스팅(Broadcasting)법칙
 
### 다른 형태의 배열 간 원소별 더하기(+)
 
```python
# (2,3) 배열과 (3, ) 배열을 더한다면?
arr_1 = np.array([[1,2,3],[4,5,6]])
arr_2 = np.array([10,20,30])

arr_1 + arr_2

>> array([[11, 22, 33],
       [14, 25, 36]])
```

### 다른 형태의 배열 간 원소별 빼기(-)

```python
# (2,3) 배열과 (3, ) 배열을 뺀다면?
arr_1 = np.array([[1,2,3],[4,5,6]])
arr_2 = np.array([10,20,30])

arr_1 - arr_2

>> array([[ -9, -18, -27],
       [ -6, -15, -24]])
```

### 다른 형태의 배열 간 원소별 곱하기(x) 
- 위와같은 연산과 다른 점이 있다. 선형대수학에서 나오는 행렬간의 곱을 참고하길 바란다.

```python
arr_1 = np.array([
                  [1,2,3],
                  [4,5,6],
                  [7,8,9]
])

arr_2 = np.array([
                  [1],
                  [10],
                  [100]
])

np.matmul(arr_1,arr_2) # 행렬간의 곱을 할때는 이와같은 np.matmul()을 사용한다.

>> array([[321],
       [654],
       [987]])
```

## 브로드캐스팅(Broadcasting) 살펴보기
### Numpy의 브로드캐스팅(Broadcasting)은
- 서로 다른 크기의 배열이나 스칼라와 배열간의 연산원리이다.
- 연산에 맞춰 적용되는 배열의 크기와 모양을 변형한다.
- 직관적인 코드구현을 위해 필요하다.

### (m, )배열과 스칼라의 연산에서 브로드캐스팅 작용

```python
np.array([0,1,2]) + 5 # 스칼라인 5가 1차원 벡터인 [5,5,5]형태로 변형된다.

>> array([5, 6, 7])
```

### (n, m)모양 행렬과 (1, m)모양행렬의 연산

```python
ary_1 = np.array([[0,0],[10,10],[20,20]])
ary_2 = np.array([1,5])

ary_1 + ary_2 # 1차원 벡터인 [1,5]가 2차원 행렬인 [[1,5],[1,5],[1,5]]으로 변형된다.

>> array([[ 1,  5],
       [11, 15],
       [21, 25]])
```

### (n, m) 모양 행렬과 (n, 1) 모양 행렬의 연산


```python
arr_1 = np.array([[0,0],[10,10],[20,20]])
arr_2 = np.array([[1],[5],[10]])

arr_1 + arr_2 # 2차원 행렬인 [[1],[5],[10]]가 [[1,1],[5,5],[10,10]]으로 변형된다.

>> array([[ 1,  1],
       [15, 15],
       [30, 30]])
```

## 브로드캐스팅(Broadcasting)성립규칙
1. 연산의 대상중 하나라도 스칼라일때 브로드캐스팅이 가능하다.
2. 배열들은 각 축의 원소의 개수가 같거나 1일때 브로드캐스팅이 가능하다.
3. 배열간 차원이 다를 경우 작은 차원을 갖는 배열에 축을 추가한 후 원칙 2를 비교한다.
4. 원칙 1,2,3중 하나라도 위배되는 경우 연산시 오류를 반환한다.


### 원칙 1. 연산의 대상중 하나라도 스칼라일때 브로드캐스팅이 가능하다.
- 모든 값이 스칼라이면서 배열과 같은 모양을 갖는 배열을 만들어 연산한다.

```python
# 예시_1 (3, ) 모양의 배열과 스칼라 5간의 연산
np.array([1,2,3]) + 5

>> array([6, 7, 8])
```
```python
# 위의 예시는 이와 같다.
arr_1 = np.array([1,2,3])
arr_2 = np.full_like(arr_1, 5)
print(arr_1)
print(arr_2)

arr_1 + arr_2

>> [1 2 3]
[5 5 5]
array([6, 7, 8])
```

### 원칙 2. 배열들은 각 축의 원소의 개수가 같거나 1일때 브로드캐스팅이 가능하다.
- 각 배열에서 원소의 개수 1인 축을 반복하여 모양을 동일하게 맞춘 후에 원소간 연산을 수행한다.

```python
# 예시_1 (2,3)배열과 (2,1) 배열간 연산
arr_1 = np.array([[0, 10, 20],[30, 40, 50]])
arr_2 = np.array([[1],[2]])

print(arr_1)
print(arr_2)
arr_1 + arr_2

>> [[ 0 10 20]
 [30 40 50]]
[[1]
 [2]]
array([[ 1, 11, 21],
       [32, 42, 52]])
```
```python
# 위의 예시는 이와 같다.
arr_2 = np.repeat(arr_2, 3 , axis=1)
print(arr_1)
print(arr_2)

arr_1 + arr_2

>> [[ 0 10 20]
 [30 40 50]]
[[1 1 1]
 [2 2 2]]
array([[ 1, 11, 21],
       [32, 42, 52]])
```

### 원칙 3. 배열간 차원이 다른 경우 작은 차원을 갖는 배열에 축을 추가한 후 원칙2를 수행한다.
1. 배열간 차원이 동일해질때까지 보다 작은 차원의 배열에 원소 1인 0번축을 추가한다.
2. (원칙2) 배열들간 각 축의 원소의 개수가 서로 같거나 1인지 비교한다.
3. (원칙2) 각 배열에서 원소의 개수가 1인축을 반복하여 모양을 동일하게 맞춘다.
4. (원칙2) 원소간의 연산을 수행한다.

```python
# 예시_1 (2,3)배열과 (3, )배열 -> ndim이 각각 2, 1
arr_1 = np.array([[10,20,30],[40,50,60]])
arr_2 = np.array([1,2,3])

print(arr_1.shape)
print(arr_2.shape)

arr_1 + arr_2

>> (2, 3)
(3,)
array([[11, 22, 33],
       [41, 52, 63]]) 
```
```python
# 위의 예시는 이와 같다.
arr_2 = np.stack([arr_2,arr_2])
print(arr_1)
print(arr_2)

arr_1 + arr_2

>> [[10 20 30]
 [40 50 60]]
[[1 2 3]
 [1 2 3]]
array([[11, 22, 33],
       [41, 52, 63]])
```

### 원칙 4. 차원을 추가해도 원칙2를 위배하는 경우 오류를 반환한다.
1. (원칙3) 차원이 같아질 때까지 원소의 개수가 1인 0번째 축을 추가했을 때
2. (원칙2) 배열들간 각 축의 원소의 개수가 서로 같거나 1이 아닐 때
3. 브로드캐스팅이 불가능하다.

## 브로드캐스팅(Broadcasting) VS for순회문 비교하기
- 브로드캐스팅(Broadcasting) : 배열의 모양을 맞추어 원소간 연산진행
- for 순회문 : 각 원소를 하나씩 꺼내어 원소간의 연산 진행

```python
ary = np.random.randint(0,20,size=20).reshape(4,5)
ary

>> array([[19,  7,  9, 18, 16],
       [ 5, 19,  0, 11,  1],
       [10,  1,  9,  5, 19],
       [ 1,  2,  9,  7,  0]])
```
```python
# for 순회문을 사용할 경우

mean_of_ary = np.mean(ary)

diff_ary = ary.copy().astype(np.float)
for row_idx, row_val in enumerate(ary):
    for col_idx, element in enumerate(row_val):
        diff_ary[row_idx, col_idx] = diff_ary[row_idx, col_idx] - mean_of_ary

diff_ary

>> array([[10.6, -1.4,  0.6,  9.6,  7.6],
       [-3.4, 10.6, -8.4,  2.6, -7.4],
       [ 1.6, -7.4,  0.6, -3.4, 10.6],
       [-7.4, -6.4,  0.6, -1.4, -8.4]])
```
```python
# numpy 브로드캐스팅을 사용했을 경우
diff_ary = ary - np.mean(ary)
diff_ary

>> array([[10.6, -1.4,  0.6,  9.6,  7.6],
       [-3.4, 10.6, -8.4,  2.6, -7.4],
       [ 1.6, -7.4,  0.6, -3.4, 10.6],
       [-7.4, -6.4,  0.6, -1.4, -8.4]])
```

### 문제_2.1번째 행의 원소값과 다른 행의 원소값 비교하기

```python
ary = np.random.randint(0, 20, size=40).reshape(8,5)
ary

>> array([[ 6, 11,  5,  0, 13],
       [ 0,  7, 11,  4, 19],
       [19, 18,  9,  6,  6],
       [13, 11, 15, 10, 11],
       [ 7, 13, 10, 12,  2],
       [16, 15,  3,  1,  6],
       [ 3, 14,  5,  8, 10],
       [ 6,  0,  9,  3, 12]])
```
```python
# for 순회문을 사용할 경우
target_vec = ary[1]

diff_ary = ary.copy()
for row_idx in range(ary.shape[0]):
    # for구문을 통해 직접 순회하며 하나씩 연산을 적용
    diff_ary[row_idx] = diff_ary[row_idx] - target_vec

diff_ary

>> array([[  6,   4,  -6,  -4,  -6],
       [  0,   0,   0,   0,   0],
       [ 19,  11,  -2,   2, -13],
       [ 13,   4,   4,   6,  -8],
       [  7,   6,  -1,   8, -17],
       [ 16,   8,  -8,  -3, -13],
       [  3,   7,  -6,   4,  -9],
       [  6,  -7,  -2,  -1,  -7]])
```
```python
# Numpy의 브로드캐스팅
ary - ary[1]

>> array([[  6,   4,  -6,  -4,  -6],
       [  0,   0,   0,   0,   0],
       [ 19,  11,  -2,   2, -13],
       [ 13,   4,   4,   6,  -8],
       [  7,   6,  -1,   8, -17],
       [ 16,   8,  -8,  -3, -13],
       [  3,   7,  -6,   4,  -9],
       [  6,  -7,  -2,  -1,  -7]])
```

### 문제_3. 1부터 5까지의 정수에서 0.1,0.5,2를 각각 곱한 모든 수 구하기

```python
arr_1 = np.array([1,2,3,4,5])
arr_2 = np.array([0.1, 0.5, 2])
```
```python
# for 순회문을 사용했을 경우

results = []
for r_v in arr_1:
    row = []
    for c_v in arr_2:
        row.append(r_v * c_v)
    results.append(row)
np.array(results)

>> array([[ 0.1,  0.5,  2. ],
       [ 0.2,  1. ,  4. ],
       [ 0.3,  1.5,  6. ],
       [ 0.4,  2. ,  8. ],
       [ 0.5,  2.5, 10. ]])
```
```python
# Numpy 브로드캐스팅을 사용했을 경우

arr_1.reshape(-1,1) * arr_2

>> array([[ 0.1,  0.5,  2. ],
       [ 0.2,  1. ,  4. ],
       [ 0.3,  1.5,  6. ],
       [ 0.4,  2. ,  8. ],
       [ 0.5,  2.5, 10. ]])
```
